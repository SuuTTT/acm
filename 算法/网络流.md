## 二分图

分成两个独立集（没有内部边的子图）

没有奇环<->这个图是二分图

匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。
最大匹配： 包含的边数最多的匹配。
完美匹配（完备匹配）：所有的点都在匹配边上的匹配。
最佳匹配：如果G为加权二分图,则权值和最大的完备匹配称为最佳匹配。

• 最⼩顶点覆盖：选最少的点覆盖所有边 

• |⼆分图最⼩顶点覆盖|=|⼆分图最⼤匹配| 

• 最⼤独⽴集：选最多的点使得它们两两没边相连 

• |⼆分图最⼤独⽴集|=总点数-|⼆分图最⼩顶点覆盖|



二分图的最小路径覆盖数=|V|-二分图的最大匹配数

> 入度出度拆点后，初始每个顶点看成一条路径，每有一个匹配，就合并了两条路径，即减少一条路径(减少一个路径起点)。

模板：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)
#define per(i,j,k) for(int i = (int)j;i >= (int)k;i --)
#define debug(x) cerr<<#x<<" = "<<(x)<<endl
#define pb push_back

typedef double db;
typedef long long ll;
const int MAXN = (int)1e3+7;
const int INF = (int)0x3f3f3f3f;

struct Dinic{
    // 用于表示表示边的结构体（终点、容量、反向边）
    struct edge{
        int to,cap,rev;
        edge(int to = 0,int cap = 0,int rev = 0):to(to),cap(cap),rev(rev){}
    };

    int N,M;
    vector<edge> G[MAXN];
    int level[MAXN]; //顶点到源点的距离标号
    int iter[MAXN];  //当前弧，在其之前的边已经没有用了

    //向图中增加一条从s到t容量为cap的边
    void add_edge(int from,int to,int cap) {
        G[from].pb(edge(to,cap,G[to].size()));
        G[to  ].pb(edge(from,0,G[from].size()-1));
    }

    //通过BFS计算从源点出发的距离标号
    void bfs(int s){
        memset(level,-1,sizeof(int)*(N+1));
        queue<int> qu;
        level[s] = 0;
        qu.push(s);
        while (!qu.empty()) {
            int v = qu.front(); qu.pop();
            rep(i,0,G[v].size()-1) {
                edge &e = G[v][i];
                if (e.cap > 0 && level[e.to] < 0) {
                    level[e.to] = level[v] + 1;
                    qu.push(e.to);
                }
            }
        }
    }

    //通过DFS寻找增广路
    int dfs(int v,int t,int f) {
        if (v == t) return f;
        for (int &i = iter[v];i < G[v].size();i ++) {
            edge &e = G[v][i];
            if (e.cap > 0 && level[v] < level[e.to]) {
                int d = dfs(e.to,t,min(f,e.cap));
                if (d > 0) {
                    e.cap -= d;
                    G[e.to][e.rev].cap += d;
                    return d;
                }
            }
        }
        return 0;
    }

    //求解从s到t的最大流
    int max_flow(int s,int t){
        int flow = 0;
        for (;;) {
            bfs(s);
            if (level[t] < 0) return flow;
            memset(iter,0,sizeof(int)*(N+1));
            int f;
            while ((f = dfs(s,t,INF)) > 0)
                flow += f;
        }
    }

    void init(int n){
        N = n;
        rep(i,1,N) G[i].clear();
    }
}d;

int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    while (cin >> d.M >> d.N){
        d.init();
        rep(i,1,d.M) {
            int x,y,w;
            cin >> x >> y >> w;
            d.add_edge(x,y,w);
        }
        cout << d.max_flow(1,d.N) << endl;
    }
}
```



Kuhn-Munkres

网格建图最大流

https://cn.vjudge.net/contest/314720#problem/E

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
#include <cctype>
using namespace std;
#define FAST_IO ios_base::sync_with_stdio(false); cin.tie(0)
#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)
#define F(i,N)for(int i = 0;i < (int)(N);i ++)
#define Decimal fixed<<setprecision(20)
inline void read(int &x) {
	x = 0; char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) x = (x << 3) + (x << 1) + c - '0', c = getchar();
}
#define MAXN 1003
struct node {
	int fr, to, va, nxt;
}edge[MAXN * MAXN * 6];
int head[MAXN * MAXN], cnt;
inline void add_edge(int u, int v, int w) {
	edge[cnt].fr = u, edge[cnt].to = v, edge[cnt].va = w;
	edge[cnt].nxt = head[u], head[u] = cnt++;
	edge[cnt].fr = v, edge[cnt].to = u, edge[cnt].va = w;
	edge[cnt].nxt = head[v], head[v] = cnt++; //反向边初始化
}
int st, ed, rk[MAXN * MAXN];
int BFS() {
	queue<int> q;
	memset(rk, 0, sizeof rk);
	rk[st] = 1;
	q.push(st);
	while (!q.empty()) {
		int tmp = q.front();
		//cout<<tmp<<endl;
		q.pop();
		for (int i = head[tmp]; i != -1; i = edge[i].nxt) {
			int o = edge[i].to;
			if (rk[o] || edge[i].va <= 0) continue;
			rk[o] = rk[tmp] + 1;
			q.push(o);
		}
	}
	return rk[ed];
}
int dfs(int u, int flow) {
	if (u == ed) return flow;
	int add = 0;
	for (int i = head[u]; i != -1 && add < flow; i = edge[i].nxt) {
		int v = edge[i].to;
		if (rk[v] != rk[u] + 1 || !edge[i].va) continue;
		int tmpadd = dfs(v, min(edge[i].va, flow - add));
		if (!tmpadd) {  //重要！就是这里！
			rk[v] = -1;
			continue;
		}
		edge[i].va -= tmpadd, edge[i ^ 1].va += tmpadd;
		add += tmpadd;
	}
	return add;
}
int ans;
void dinic() {
	while (BFS()) ans += dfs(st, 0x3fffff);
}
int n, m;
inline int gethash(int i, int j) {
	return (i - 1) * m + j;
}
int main() {
	memset(head, -1, sizeof head);
	cin >> n >> m;
	int tmp;
	st = 1, ed = gethash(n, m);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j < m; ++j)
			cin >> tmp, add_edge(gethash(i, j), gethash(i, j + 1), tmp);
	}
	for (int i = 1; i < n; ++i) {
		for (int j = 1; j <= m; ++j)
			cin>>tmp, add_edge(gethash(i, j), gethash(i + 1, j), tmp);
	}
	for (int i = 1; i < n; ++i) {
		for (int j = 1; j < m; ++j)
			cin>>tmp, add_edge(gethash(i, j), gethash(i + 1, j + 1), tmp);
	}
	dinic();
	cout << ans << endl;
	cin >> n;
	return 0;
}
```

