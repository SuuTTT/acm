# 几何模板 1024

## 基础函数

### 基础模板与凸包

```cpp
#define Decimal fixed<<setprecision(20)

//typedef long long ll;
const int maxn = 105;
typedef double db;
typedef double ld;
const double eps = 1e-7;
const double pi = acos(-1.);
inline int sign(double d) { return d<-eps ? -1 : d>eps; }
inline int cmp(db a, db b) { return sign(a - b); }
struct P {
	db x, y;
	P() {};
	P(db x, db y) :x(x), y(y) {}
	void read() { cin >> x >> y; }
	void write() { cout << '(' << x << ',' << y << ')'; }
	P operator + (P o) { return P(x + o.x, y + o.y); }
	P operator - (P o) { return P(x - o.x, y - o.y); }
	P operator *(db d) { return P(x * d, y * d); }
	P operator /(db d) { return P(x / d, y / d); }
	db operator *(P o) { return (x*o.x + y * o.y); }
	db operator |(const P &o) const{ return x * o.y - y * o.x; }
	bool operator==(P p)const {
		return cmp(x, p.x) == 0 && cmp(y, p.y) == 0;
	}
	db abs() { return (x*x + y * y); }
	db abs2() { return (x*x + y * y); }
	db distTo(P p) { return (*this - p).abs(); }
	db alpha() { return atan2(y, x); }
	P rot90() { return P(-y, x); }
	P rot(db a) { return P(x*cos(a) - y * sin(a), x*sin(a) + y * cos(a)); }
	P unit() { return *this / abs(); }
	int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }
}p[maxn], q[maxn];

vector<P> ConvexHull(vector<P>A, int flag = 1) { // flag=0 不严格 flag=1 严格 ，不用极角排序
	int n = A.size(); vector<P>ans(n * 2);
	sort(A.begin(), A.end()); int now = -1;
	for (int i = 0; i<A.size(); i++) {
		while (now>0 && sign((ans[now] - ans[now - 1])| (A[i] - ans[now - 1]))<flag) now--;
		ans[++now] = A[i];
	} int pre = now;
	for (int i = n - 2; i >= 0; i--) {
		while (now>pre&&sign((ans[now] - ans[now - 1])|( A[i] - ans[now - 1]))<flag) now--;
		ans[++now] = A[i];
	} ans.resize(now); return ans;
}
```



### 半平面交 + 凸多边形交例题

```cpp
P getLL(P k1, P k2,P k3, P k4) {
	db w1 = (k1 - k3)|( k4 - k3), w2 = (k4 - k3)| (k2 - k3); return (k1*w2 + k2 * w1) / (w1 + w2);
}
int compareangle(  P k1, P k2) {//极点为原点的极角排序
	return k1.quad()<k2.quad() || (k1.quad() == k2.quad() && sign(k1| k2)>0);
}
struct L {
	//p[0]->p[1]
	P p[2];
	L(P k1, P k2) { p[0] = k1; p[1] = k2; }
	P& operator [](int k){ return p[k]; }
	P dir() { return p[1] - p[0]; }
	int include(P k) { return sign((p[1] - p[0])|( k - p[0]))>0; }//判点在线上
};
P getLL(L k1, L k2) {return getLL(k1[0], k1[1], k2[0], k2[1]);}
int parallel(L k1, L k2) { return sign((k1.dir()| k2.dir())) == 0; }
int sameDir(L k1, L k2) { return parallel(k1, k2) && sign(k1.dir()* k2.dir()) == 1; }
int checkpos(L k1, L k2, L k3) { return k3.include(getLL(k1, k2)); }//k1k2交点是否在k3上
int operator < (L k1, L k2) {
	if (sameDir(k1, k2)) return k2.include(k1[0]);
	return compareangle(k1.dir(), k2.dir());
}
vector<L> getHL(vector<L> &V) { // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针
	sort(V.begin(), V.end()); 
	deque<L> q;
	for (int i = 0; i<(int)V.size(); i++) {
		if (i&&sameDir(V[i], V[i - 1])) continue;
		while (q.size()>1 && !checkpos(q[q.size() - 2], q[q.size() - 1], V[i])) q.pop_back();//V[i]把凸包（半平面）切得更小
		while (q.size()>1 && !checkpos(q[1], q[0], V[i])) q.pop_front();
		q.push_back(V[i]);
	}
	while (q.size()>2 && !checkpos(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back();
	while (q.size()>2 && !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front();
	vector<L>ans; for (int i = 0; i<q.size(); i++) ans.push_back(q[i]);
	return ans;
}
db area(vector<P> A) { // 多边形用 vector<point> 表示 , 逆时针 
	db ans = 0;
	for (int i = 0; i<A.size(); i++) ans += (A[i]| A[(i + 1) % A.size()]);
	return ans / 2;
}
vector<L> lin;
vector<P> pin;
int main()
{

	int n;
	cin >> n;
	rep(i, 1, n) {
		vector<P> tmp;
		int m; cin >> m;
		rep(i, 1, m) {
			P p;
			p.read();
			tmp.push_back(p);
		}
		for (int i = 0; i < tmp.size(); i++) {
			lin.push_back(L(tmp[i], tmp[(i + 1) % tmp.size()]));
		}
	}
	lin = getHL(lin);
	if (lin.size() == 2){
		cout << "0.000"; cin >> n; return 0;
	}
	for (int i = 0; i < lin.size(); i++) {
		pin.push_back(getLL(lin[i], lin[(i + 1) % lin.size()]));
	}
	sort(pin.begin(), pin.end(), compareangle);
	//cout << Decimal<<area(pin) << endl;
	printf("%.3lf", area(pin));
	cin >> n;
	return 0;
}
```



### 



```cpp
#define mp make_pair
#define fi first
#define se second
#define pb push_back
typedef double db;
const db eps=1e-6;
const db pi=acos(-1);
int sign(db k){
    if (k>eps) return 1; else if (k<-eps) return -1; return 0;
}
int cmp(db k1,db k2){return sign(k1-k2);}
int inmid(db k1,db k2,db k3){return sign(k1-k3)*sign(k2-k3)<=0;}// k3 在 [k1,k2] 内 
struct point{
    db x,y;
    point operator + (const point &k1) const{return (point){k1.x+x,k1.y+y};}
    point operator - (const point &k1) const{return (point){x-k1.x,y-k1.y};}
    point operator * (db k1) const{return (point){x*k1,y*k1};}
    point operator / (db k1) const{return (point){x/k1,y/k1};}
    int operator == (const point &k1) const{return cmp(x,k1.x)==0&&cmp(y,k1.y)==0;}
    // 逆时针旋转 
    point turn(db k1){return (point){x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1)};}
    point turn90(){return (point){-y,x};}
    bool operator < (const point k1) const{
        int a=cmp(x,k1.x);
        if (a==-1) return 1; else if (a==1) return 0; else return cmp(y,k1.y)==-1;
    }
    db abs(){return sqrt(x*x+y*y);}
    db abs2(){return x*x+y*y;}
    db dis(point k1){return ((*this)-k1).abs();}
    point unit(){db w=abs(); return (point){x/w,y/w};}
    void scan(){double k1,k2; scanf("%lf%lf",&k1,&k2); x=k1; y=k2;}
    void print(){printf("%.11lf %.11lf\n",x,y);}
    db getw(){return atan2(y,x);} 
    point getdel(){if (sign(x)==-1||(sign(x)==0&&sign(y)==-1)) return (*this)*(-1); else return (*this);}
	int getP() const{return sign(y)==1||(sign(y)==0&&sign(x)==-1);}
};
int inmid(point k1,point k2,point k3){return inmid(k1.x,k2.x,k3.x)&&inmid(k1.y,k2.y,k3.y);}
db cross(point k1,point k2){return k1.x*k2.y-k1.y*k2.x;}
db dot(point k1,point k2){return k1.x*k2.x+k1.y*k2.y;}
db rad(point k1,point k2){return atan2(cross(k1,k2),dot(k1,k2));}
// -pi -> pi
int compareangle (point k1,point k2){
    return k1.getP()<k2.getP()||(k1.getP()==k2.getP()&&sign(cross(k1,k2))>0);
}
point proj(point k1,point k2,point q){ // q 到直线 k1,k2 的投影 
    point k=k2-k1; return k1+k*(dot(q-k1,k)/k.abs2());
}
point reflect(point k1,point k2,point q){return proj(k1,k2,q)*2-q;}
int clockwise(point k1,point k2,point k3){// k1 k2 k3 逆时针 1 顺时针 -1 否则 0  
    return sign(cross(k2-k1,k3-k1));
}
int checkLL(point k1,point k2,point k3,point k4){// 求直线 (L) 线段 (S)k1,k2 和 k3,k4 的交点 
    return cmp(cross(k3-k1,k4-k1),cross(k3-k2,k4-k2))!=0;
}
point getLL(point k1,point k2,point k3,point k4){
    db w1=cross(k1-k3,k4-k3),w2=cross(k4-k3,k2-k3); return (k1*w2+k2*w1)/(w1+w2);
}
int intersect(db l1,db r1,db l2,db r2){
    if (l1>r1) swap(l1,r1); if (l2>r2) swap(l2,r2); return cmp(r1,l2)!=-1&&cmp(r2,l1)!=-1;
}
int checkSS(point k1,point k2,point k3,point k4){
    return intersect(k1.x,k2.x,k3.x,k4.x)&&intersect(k1.y,k2.y,k3.y,k4.y)&&
    sign(cross(k3-k1,k4-k1))*sign(cross(k3-k2,k4-k2))<=0&&
    sign(cross(k1-k3,k2-k3))*sign(cross(k1-k4,k2-k4))<=0;
}
db disSP(point k1,point k2,point q){
    point k3=proj(k1,k2,q);
    if (inmid(k1,k2,k3)) return q.dis(k3); else return min(q.dis(k1),q.dis(k2));
}
db disSS(point k1,point k2,point k3,point k4){
    if (checkSS(k1,k2,k3,k4)) return 0;
    else return min(min(disSP(k1,k2,k3),disSP(k1,k2,k4)),min(disSP(k3,k4,k1),disSP(k3,k4,k2)));
}
int onS(point k1,point k2,point q){return inmid(k1,k2,q)&&sign(cross(k1-q,k2-k1))==0;}
struct circle{
    point o; db r;
    void scan(){o.scan(); scanf("%lf",&r);}
    int inside(point k){return cmp(r,o.dis(k));}
};
struct line{
    // p[0]->p[1]
    point p[2];
    line(point k1,point k2){p[0]=k1; p[1]=k2;}
    point& operator [] (int k){return p[k];}
    int include(point k){return sign(cross(p[1]-p[0],k-p[0]))>0;}
    point dir(){return p[1]-p[0];}
    line push(){ // 向外 ( 左手边 ) 平移 eps 
        const db eps = 1e-6;
        point delta=(p[1]-p[0]).turn90().unit()*eps;
        return {p[0]-delta,p[1]-delta};
    }
};
point getLL(line k1,line k2){return getLL(k1[0],k1[1],k2[0],k2[1]);}
int parallel(line k1,line k2){return sign(cross(k1.dir(),k2.dir()))==0;}
int sameDir(line k1,line k2){return parallel(k1,k2)&&sign(dot(k1.dir(),k2.dir()))==1;}
int operator < (line k1,line k2){
    if (sameDir(k1,k2)) return k2.include(k1[0]); 
    return compareangle(k1.dir(),k2.dir());
}
int checkpos(line k1,line k2,line k3){return k3.include(getLL(k1,k2));}
vector<line> getHL(vector<line> &L){ // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针
    sort(L.begin(),L.end()); deque<line> q;
    for (int i=0;i<(int)L.size();i++){
        if (i&&sameDir(L[i],L[i-1])) continue;
        while (q.size()>1&&!checkpos(q[q.size()-2],q[q.size()-1],L[i])) q.pop_back();
        while (q.size()>1&&!checkpos(q[1],q[0],L[i])) q.pop_front();
        q.push_back(L[i]);
    }
    while (q.size()>2&&!checkpos(q[q.size()-2],q[q.size()-1],q[0])) q.pop_back();
    while (q.size()>2&&!checkpos(q[1],q[0],q[q.size()-1])) q.pop_front();
    vector<line>ans; for (int i=0;i<q.size();i++) ans.push_back(q[i]);
    return ans;
}
db closepoint(vector<point>&A,int l,int r){ // 最近点对 , 先要按照 x 坐标排序 
    if (r-l<=5){
        db ans=1e20;
        for (int i=l;i<=r;i++) for (int j=i+1;j<=r;j++) ans=min(ans,A[i].dis(A[j]));
        return ans;
    }
    int mid=l+r>>1; db ans=min(closepoint(A,l,mid),closepoint(A,mid+1,r));
    vector<point>B; for (int i=l;i<=r;i++) if (abs(A[i].x-A[mid].x)<=ans) B.push_back(A[i]);
    sort(B.begin(),B.end(),[](point k1,point k2){return k1.y<k2.y;});
    for (int i=0;i<B.size();i++) for (int j=i+1;j<B.size()&&B[j].y-B[i].y<ans;j++) ans=min(ans,B[i].dis(B[j]));
    return ans;
}
int checkposCC(circle k1,circle k2){// 返回两个圆的公切线数量
    if (cmp(k1.r,k2.r)==-1) swap(k1,k2);
    db dis=k1.o.dis(k2.o);  int w1=cmp(dis,k1.r+k2.r),w2=cmp(dis,k1.r-k2.r);
    if (w1>0) return 4; else if (w1==0) return 3; else if (w2>0) return 2; 
    else if (w2==0) return 1; else return 0;
}
vector<point> getCL(circle k1,point k2,point k3){ // 沿着 k2->k3 方向给出 , 相切给出两个 
    point k=proj(k2,k3,k1.o); db d=k1.r*k1.r-(k-k1.o).abs2();
    if (sign(d)==-1) return {};
    point del=(k3-k2).unit()*sqrt(max((db)0.0,d)); return {k-del,k+del};
}
vector<point> getCC(circle k1,circle k2){// 沿圆 k1 逆时针给出 , 相切给出两个 
    int pd=checkposCC(k1,k2); if (pd==0||pd==4) return {};
    db a=(k2.o-k1.o).abs2(),cosA=(k1.r*k1.r+a-k2.r*k2.r)/(2*k1.r*sqrt(max(a,(db)0.0)));
    db b=k1.r*cosA,c=sqrt(max((db)0.0,k1.r*k1.r-b*b));
    point k=(k2.o-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;
    return {m-del,m+del};
} 
vector<point> TangentCP(circle k1,point k2){// 沿圆 k1 逆时针给出 
    db a=(k2-k1.o).abs(),b=k1.r*k1.r/a,c=sqrt(max((db)0.0,k1.r*k1.r-b*b));
    point k=(k2-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;
    return {m-del,m+del};
} 
vector<line> TangentoutCC(circle k1,circle k2){
    int pd=checkposCC(k1,k2); if (pd==0) return {}; 
    if (pd==1){point k=getCC(k1,k2)[0]; return {(line){k,k}};}
    if (cmp(k1.r,k2.r)==0){
        point del=(k2.o-k1.o).unit().turn90().getdel();
        return {(line){k1.o-del*k1.r,k2.o-del*k2.r},(line){k1.o+del*k1.r,k2.o+del*k2.r}};
    } else {
        point p=(k2.o*k1.r-k1.o*k2.r)/(k1.r-k2.r);
        vector<point>A=TangentCP(k1,p),B=TangentCP(k2,p);
        vector<line>ans; for (int i=0;i<A.size();i++) ans.push_back((line){A[i],B[i]}); 
        return ans;
    }
}
vector<line> TangentinCC(circle k1,circle k2){
    int pd=checkposCC(k1,k2); if (pd<=2) return {};
    if (pd==3){point k=getCC(k1,k2)[0]; return {(line){k,k}};} 
    point p=(k2.o*k1.r+k1.o*k2.r)/(k1.r+k2.r);
    vector<point>A=TangentCP(k1,p),B=TangentCP(k2,p);
    vector<line>ans; for (int i=0;i<A.size();i++) ans.push_back((line){A[i],B[i]}); 
    return ans;
}
vector<line> TangentCC(circle k1,circle k2){
    int flag=0; if (k1.r<k2.r) swap(k1,k2),flag=1;
    vector<line>A=TangentoutCC(k1,k2),B=TangentinCC(k1,k2);
    for (line k:B) A.push_back(k); 
    if (flag) for (line &k:A) swap(k[0],k[1]);
    return A;
}
db getarea(circle k1,point k2,point k3){
    // 圆 k1 与三角形 k2 k3 k1.o 的有向面积交
    point k=k1.o; k1.o=k1.o-k; k2=k2-k; k3=k3-k;
    int pd1=k1.inside(k2),pd2=k1.inside(k3); 
    vector<point>A=getCL(k1,k2,k3);
    if (pd1>=0){
        if (pd2>=0) return cross(k2,k3)/2;
        return k1.r*k1.r*rad(A[1],k3)/2+cross(k2,A[1])/2;
    } else if (pd2>=0){ 
        return k1.r*k1.r*rad(k2,A[0])/2+cross(A[0],k3)/2;
    }else {
        int pd=cmp(k1.r,disSP(k2,k3,k1.o));
        if (pd<=0) return k1.r*k1.r*rad(k2,k3)/2;
        return cross(A[0],A[1])/2+k1.r*k1.r*(rad(k2,A[0])+rad(A[1],k3))/2;
    }
}
circle getcircle(point k1,point k2,point k3){
    db a1=k2.x-k1.x,b1=k2.y-k1.y,c1=(a1*a1+b1*b1)/2;
    db a2=k3.x-k1.x,b2=k3.y-k1.y,c2=(a2*a2+b2*b2)/2;
    db d=a1*b2-a2*b1;
    point o=(point){k1.x+(c1*b2-c2*b1)/d,k1.y+(a1*c2-a2*c1)/d};
    return (circle){o,k1.dis(o)};
}
circle getScircle(vector<point> A){
    random_shuffle(A.begin(),A.end());
    circle ans=(circle){A[0],0};
    for (int i=1;i<A.size();i++)
        if (ans.inside(A[i])==-1){
            ans=(circle){A[i],0};
            for (int j=0;j<i;j++)
                if (ans.inside(A[j])==-1){
                    ans.o=(A[i]+A[j])/2; ans.r=ans.o.dis(A[i]);
                    for (int k=0;k<j;k++)
                        if (ans.inside(A[k])==-1)
                            ans=getcircle(A[i],A[j],A[k]);
                }
        }
    return ans;
}
db area(vector<point> A){ // 多边形用 vector<point> 表示 , 逆时针 
    db ans=0;
    for (int i=0;i<A.size();i++) ans+=cross(A[i],A[(i+1)%A.size()]);
    return ans/2;
}
int checkconvex(vector<point>A){
    int n=A.size(); A.push_back(A[0]); A.push_back(A[1]);
    for (int i=0;i<n;i++) if (sign(cross(A[i+1]-A[i],A[i+2]-A[i]))==-1) return 0;
    return 1;
}
int contain(vector<point>A,point q){ // 2 内部 1 边界 0 外部
    int pd=0; A.push_back(A[0]);
    for (int i=1;i<A.size();i++){
        point u=A[i-1],v=A[i];
        if (onS(u,v,q)) return 1; if (cmp(u.y,v.y)>0) swap(u,v);
        if (cmp(u.y,q.y)>=0||cmp(v.y,q.y)<0) continue;
        if (sign(cross(u-v,q-v))<0) pd^=1;
    }
    return pd<<1;
}
vector<point> ConvexHull(vector<point>A,int flag=1){ // flag=0 不严格 flag=1 严格 
    int n=A.size(); vector<point>ans(n*2); 
    sort(A.begin(),A.end()); int now=-1;
    for (int i=0;i<A.size();i++){
        while (now>0&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;
        ans[++now]=A[i];
    } int pre=now;
    for (int i=n-2;i>=0;i--){
        while (now>pre&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;
        ans[++now]=A[i];
    } ans.resize(now); return ans;
}
db convexDiameter(vector<point>A){
    int now=0,n=A.size(); db ans=0;
    for (int i=0;i<A.size();i++){
        now=max(now,i);
        while (1){
            db k1=A[i].dis(A[now%n]),k2=A[i].dis(A[(now+1)%n]);
            ans=max(ans,max(k1,k2)); if (k2>k1) now++; else break;
        }
    }
    return ans;
}
vector<point> convexcut(vector<point>A,point k1,point k2){
    // 保留 k1,k2,p 逆时针的所有点
    int n=A.size(); A.push_back(A[0]); vector<point>ans;
    for (int i=0;i<n;i++){
        int w1=clockwise(k1,k2,A[i]),w2=clockwise(k1,k2,A[i+1]);
        if (w1>=0) ans.push_back(A[i]);
        if (w1*w2<0) ans.push_back(getLL(k1,k2,A[i],A[i+1]));
    }
    return ans;
}
int checkPoS(vector<point>A,point k1,point k2){
    // 多边形 A 和直线 ( 线段 )k1->k2 严格相交 , 注释部分为线段
    struct ins{
        point m,u,v;
        int operator < (const ins& k) const {return m<k.m;}
    }; vector<ins>B;
    //if (contain(A,k1)==2||contain(A,k2)==2) return 1;
    vector<point>poly=A; A.push_back(A[0]); 
    for (int i=1;i<A.size();i++) if (checkLL(A[i-1],A[i],k1,k2)){
        point m=getLL(A[i-1],A[i],k1,k2); 
        if (inmid(A[i-1],A[i],m)/*&&inmid(k1,k2,m)*/) B.push_back((ins){m,A[i-1],A[i]});
    }
    if (B.size()==0) return 0; sort(B.begin(),B.end()); 
    int now=1; while (now<B.size()&&B[now].m==B[0].m) now++; 
    if (now==B.size()) return 0;
    int flag=contain(poly,(B[0].m+B[now].m)/2);
    if (flag==2) return 1;
    point d=B[now].m-B[0].m;
    for (int i=now;i<B.size();i++){
        if (!(B[i].m==B[i-1].m)&&flag==2) return 1;
        int tag=sign(cross(B[i].v-B[i].u,B[i].m+d-B[i].u));
        if (B[i].m==B[i].u||B[i].m==B[i].v) flag+=tag; else flag+=tag*2;
    }
    //return 0;
    return flag==2;
}
int checkinp(point r,point l,point m){
	if (compareangle(l,r)){return compareangle(l,m)&&compareangle(m,r);}
	return compareangle(l,m)||compareangle(m,r);
}
int checkPosFast(vector<point>A,point k1,point k2){ // 快速检查线段是否和多边形严格相交
	if (contain(A,k1)==2||contain(A,k2)==2) return 1; if (k1==k2) return 0;
	A.push_back(A[0]); A.push_back(A[1]);
	for (int i=1;i+1<A.size();i++)
		if (checkLL(A[i-1],A[i],k1,k2)){
			point now=getLL(A[i-1],A[i],k1,k2);
			if (inmid(A[i-1],A[i],now)==0||inmid(k1,k2,now)==0) continue;
			if (now==A[i]){
				if (A[i]==k2) continue;
				point pre=A[i-1],ne=A[i+1];
				if (checkinp(pre-now,ne-now,k2-now)) return 1;
			} else if (now==k1){
				if (k1==A[i-1]||k1==A[i]) continue;
				if (checkinp(A[i-1]-k1,A[i]-k1,k2-k1)) return 1;
			} else if (now==k2||now==A[i-1]) continue;
			else return 1;
		}
	return 0;
}
// 拆分凸包成上下凸壳 凸包尽量都随机旋转一个角度来避免出现相同横坐标 
// 尽量特判只有一个点的情况 凸包逆时针
void getUDP(vector<point>A,vector<point>&U,vector<point>&D){
    db l=1e100,r=-1e100;
    for (int i=0;i<A.size();i++) l=min(l,A[i].x),r=max(r,A[i].x);
    int wherel,wherer;
    for (int i=0;i<A.size();i++) if (cmp(A[i].x,l)==0) wherel=i;
    for (int i=A.size();i;i--) if (cmp(A[i-1].x,r)==0) wherer=i-1;
    U.clear(); D.clear(); int now=wherel;
    while (1){D.push_back(A[now]); if (now==wherer) break; now++; if (now>=A.size()) now=0;}
    now=wherel;
    while (1){U.push_back(A[now]); if (now==wherer) break; now--; if (now<0) now=A.size()-1;}
}
// 需要保证凸包点数大于等于 3,2 内部 ,1 边界 ,0 外部
int containCoP(const vector<point>&U,const vector<point>&D,point k){
    db lx=U[0].x,rx=U[U.size()-1].x;
    if (k==U[0]||k==U[U.size()-1]) return 1;
    if (cmp(k.x,lx)==-1||cmp(k.x,rx)==1) return 0;
    int where1=lower_bound(U.begin(),U.end(),(point){k.x,-1e100})-U.begin();
    int where2=lower_bound(D.begin(),D.end(),(point){k.x,-1e100})-D.begin();
    int w1=clockwise(U[where1-1],U[where1],k),w2=clockwise(D[where2-1],D[where2],k);
    if (w1==1||w2==-1) return 0; else if (w1==0||w2==0) return 1; return 2;
}
// d 是方向 , 输出上方切点和下方切点
pair<point,point> getTangentCow(const vector<point> &U,const vector<point> &D,point d){
    if (sign(d.x)<0||(sign(d.x)==0&&sign(d.y)<0)) d=d*(-1);
    point whereU,whereD;
    if (sign(d.x)==0) return mp(U[0],U[U.size()-1]);
    int l=0,r=U.size()-1,ans=0;
    while (l<r){int mid=l+r>>1; if (sign(cross(U[mid+1]-U[mid],d))<=0) l=mid+1,ans=mid+1; else r=mid;}
    whereU=U[ans]; l=0,r=D.size()-1,ans=0;
    while (l<r){int mid=l+r>>1; if (sign(cross(D[mid+1]-D[mid],d))>=0) l=mid+1,ans=mid+1; else r=mid;}
    whereD=D[ans]; return mp(whereU,whereD);
}
// 先检查 contain, 逆时针给出
pair<point,point> getTangentCoP(const vector<point>&U,const vector<point>&D,point k){
    db lx=U[0].x,rx=U[U.size()-1].x;
    if (k.x<lx){
        int l=0,r=U.size()-1,ans=U.size()-1;
        while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;}
        point w1=U[ans]; l=0,r=D.size()-1,ans=D.size()-1;
        while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;}
        point w2=D[ans]; return mp(w1,w2);
    } else if (k.x>rx){
        int l=1,r=U.size(),ans=0;
        while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid-1])==-1) r=mid; else ans=mid,l=mid+1;}
        point w1=U[ans]; l=1,r=D.size(),ans=0;
        while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid-1])==1) r=mid; else ans=mid,l=mid+1;}
        point w2=D[ans]; return mp(w2,w1);
    } else {
        int where1=lower_bound(U.begin(),U.end(),(point){k.x,-1e100})-U.begin();
        int where2=lower_bound(D.begin(),D.end(),(point){k.x,-1e100})-D.begin();
        if ((k.x==lx&&k.y>U[0].y)||(where1&&clockwise(U[where1-1],U[where1],k)==1)){
            int l=1,r=where1+1,ans=0;
            while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid-1])==1) ans=mid,l=mid+1; else r=mid;}
            point w1=U[ans]; l=where1,r=U.size()-1,ans=U.size()-1;
            while (l<r){int mid=l+r>>1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;}
            point w2=U[ans]; return mp(w2,w1);
        } else {
            int l=1,r=where2+1,ans=0;
            while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid-1])==-1) ans=mid,l=mid+1; else r=mid;}
            point w1=D[ans]; l=where2,r=D.size()-1,ans=D.size()-1;
            while (l<r){int mid=l+r>>1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;}
            point w2=D[ans]; return mp(w1,w2);
        }
    }
}
struct P3{
    db x,y,z;
    P3 operator + (P3 k1){return (P3){x+k1.x,y+k1.y,z+k1.z};}
    P3 operator - (P3 k1){return (P3){x-k1.x,y-k1.y,z-k1.z};}
    P3 operator * (db k1){return (P3){x*k1,y*k1,z*k1};}
    P3 operator / (db k1){return (P3){x/k1,y/k1,z/k1};}
    db abs2(){return x*x+y*y+z*z;}
    db abs(){return sqrt(x*x+y*y+z*z);}
    P3 unit(){return (*this)/abs();}
    int operator < (const P3 k1) const{
        if (cmp(x,k1.x)!=0) return x<k1.x;
        if (cmp(y,k1.y)!=0) return y<k1.y;
        return cmp(z,k1.z)==-1;
    }
    int operator == (const P3 k1){
        return cmp(x,k1.x)==0&&cmp(y,k1.y)==0&&cmp(z,k1.z)==0;
    }
    void scan(){
        double k1,k2,k3; scanf("%lf%lf%lf",&k1,&k2,&k3);
        x=k1; y=k2; z=k3;
    }
};
P3 cross(P3 k1,P3 k2){return (P3){k1.y*k2.z-k1.z*k2.y,k1.z*k2.x-k1.x*k2.z,k1.x*k2.y-k1.y*k2.x};}
db dot(P3 k1,P3 k2){return k1.x*k2.x+k1.y*k2.y+k1.z*k2.z;}
//p=(3,4,5),l=(13,19,21),theta=85 ans=(2.83,4.62,1.77)
P3 turn3D(db k1,P3 l,P3 p){
    l=l.unit(); P3 ans; db c=cos(k1),s=sin(k1);
    ans.x=p.x*(l.x*l.x*(1-c)+c)+p.y*(l.x*l.y*(1-c)-l.z*s)+p.z*(l.x*l.z*(1-c)+l.y*s);
    ans.y=p.x*(l.x*l.y*(1-c)+l.z*s)+p.y*(l.y*l.y*(1-c)+c)+p.z*(l.y*l.z*(1-c)-l.x*s);
    ans.z=p.x*(l.x*l.z*(1-c)-l.y*s)+p.y*(l.y*l.z*(1-c)+l.x*s)+p.z*(l.x*l.x*(1-c)+c);
    return ans;
}
typedef vector<P3> VP;
typedef vector<VP> VVP;
db Acos(db x){return acos(max(-(db)1,min(x,(db)1)));}
// 球面距离 , 圆心原点 , 半径 1
db Odist(P3 a,P3 b){db r=Acos(dot(a,b)); return r;}
db r; P3 rnd;
vector<db> solve(db a,db b,db c){
    db r=sqrt(a*a+b*b),th=atan2(b,a);
    if (cmp(c,-r)==-1) return {0};
    else if (cmp(r,c)<=0) return {1};
    else {
        db tr=pi-Acos(c/r); return {th+pi-tr,th+pi+tr};
    }
}
vector<db> jiao(P3 a,P3 b){
    // dot(rd+x*cos(t)+y*sin(t),b) >= cos(r)
    if (cmp(Odist(a,b),2*r)>0) return {0};
    P3 rd=a*cos(r),z=a.unit(),y=cross(z,rnd).unit(),x=cross(y,z).unit();
    vector<db> ret = solve(-(dot(x,b)*sin(r)),-(dot(y,b)*sin(r)),-(cos(r)-dot(rd,b))); 
    return ret;
}
db norm(db x,db l=0,db r=2*pi){ // change x into [l,r)
    while (cmp(x,l)==-1) x+=(r-l); while (cmp(x,r)>=0) x-=(r-l);
    return x;
}
db disLP(P3 k1,P3 k2,P3 q){
    return (cross(k2-k1,q-k1)).abs()/(k2-k1).abs();
}
db disLL(P3 k1,P3 k2,P3 k3,P3 k4){
    P3 dir=cross(k2-k1,k4-k3); if (sign(dir.abs())==0) return disLP(k1,k2,k3);
    return fabs(dot(dir.unit(),k1-k2));
}
VP getFL(P3 p,P3 dir,P3 k1,P3 k2){
    db a=dot(k2-p,dir),b=dot(k1-p,dir),d=a-b;
    if (sign(fabs(d))==0) return {};
    return {(k1*a-k2*b)/d};
}
VP getFF(P3 p1,P3 dir1,P3 p2,P3 dir2){// 返回一条线
    P3 e=cross(dir1,dir2),v=cross(dir1,e);
    db d=dot(dir2,v); if (sign(abs(d))==0) return {};
    P3 q=p1+v*dot(dir2,p2-p1)/d; return {q,q+e};
}
// 3D Covex Hull Template
db getV(P3 k1,P3 k2,P3 k3,P3 k4){ // get the Volume
    return dot(cross(k2-k1,k3-k1),k4-k1);
}
db rand_db(){return 1.0*rand()/RAND_MAX;}
VP convexHull2D(VP A,P3 dir){
    P3 x={(db)rand(),(db)rand(),(db)rand()}; x=x.unit();
    x=cross(x,dir).unit(); P3 y=cross(x,dir).unit();
    P3 vec=dir.unit()*dot(A[0],dir);
    vector<point>B;
    for (int i=0;i<A.size();i++) B.push_back((point){dot(A[i],x),dot(A[i],y)});
    B=ConvexHull(B); A.clear();
    for (int i=0;i<B.size();i++) A.push_back(x*B[i].x+y*B[i].y+vec);
    return A;
}
namespace CH3{
    VVP ret; set<pair<int,int> >e;
    int n; VP p,q;
    void wrap(int a,int b){
        if (e.find({a,b})==e.end()){
            int c=-1;
            for (int i=0;i<n;i++) if (i!=a&&i!=b){
                if (c==-1||sign(getV(q[c],q[a],q[b],q[i]))>0) c=i;
            }
            if (c!=-1){
                ret.push_back({p[a],p[b],p[c]});
                e.insert({a,b}); e.insert({b,c}); e.insert({c,a});
                wrap(c,b); wrap(a,c);
            }
        }
    }
    VVP ConvexHull3D(VP _p){
        p=q=_p; n=p.size();
        ret.clear(); e.clear();
        for (auto &i:q) i=i+(P3){rand_db()*1e-4,rand_db()*1e-4,rand_db()*1e-4};
        for (int i=1;i<n;i++) if (q[i].x<q[0].x) swap(p[0],p[i]),swap(q[0],q[i]);
        for (int i=2;i<n;i++) if ((q[i].x-q[0].x)*(q[1].y-q[0].y)>(q[i].y-q[0].y)*(q[1].x-q[0].x)) swap(q[1],q[i]),swap(p[1],p[i]);
        wrap(0,1);
        return ret;
    }
}
VVP reduceCH(VVP A){
    VVP ret; map<P3,VP> M;
    for (VP nowF:A){
        P3 dir=cross(nowF[1]-nowF[0],nowF[2]-nowF[0]).unit();
        for (P3 k1:nowF) M[dir].pb(k1);
    }
    for (pair<P3,VP> nowF:M) ret.pb(convexHull2D(nowF.se,nowF.fi));
    return ret;
}
//  把一个面变成 ( 点 , 法向量 ) 的形式
pair<P3,P3> getF(VP F){
    return mp(F[0],cross(F[1]-F[0],F[2]-F[0]).unit());
}
// 3D Cut 保留 dot(dir,x-p)>=0 的部分
VVP ConvexCut3D(VVP A,P3 p,P3 dir){
    VVP ret; VP sec;
    for (VP nowF: A){
        int n=nowF.size(); VP ans; int dif=0;
        for (int i=0;i<n;i++){
            int d1=sign(dot(dir,nowF[i]-p));
            int d2=sign(dot(dir,nowF[(i+1)%n]-p));
            if (d1>=0) ans.pb(nowF[i]);
            if (d1*d2<0){
                P3 q=getFL(p,dir,nowF[i],nowF[(i+1)%n])[0];
                ans.push_back(q); sec.push_back(q);
            }
            if (d1==0) sec.push_back(nowF[i]); else dif=1;
            dif|=(sign(dot(dir,cross(nowF[(i+1)%n]-nowF[i],nowF[(i+1)%n]-nowF[i])))==-1);
        }
        if (ans.size()>0&&dif) ret.push_back(ans);
    }
    if (sec.size()>0) ret.push_back(convexHull2D(sec,dir));
    return ret;
}
db vol(VVP A){
    if (A.size()==0) return 0; P3 p=A[0][0]; db ans=0;
    for (VP nowF:A)
        for (int i=2;i<nowF.size();i++)
            ans+=abs(getV(p,nowF[0],nowF[i-1],nowF[i]));
    return ans/6;
}
VVP init(db INF) {
    VVP pss(6,VP(4));
    pss[0][0] = pss[1][0] = pss[2][0] = {-INF, -INF, -INF};
    pss[0][3] = pss[1][1] = pss[5][2] = {-INF, -INF, INF};
    pss[0][1] = pss[2][3] = pss[4][2] = {-INF, INF, -INF};
    pss[0][2] = pss[5][3] = pss[4][1] = {-INF, INF, INF};
    pss[1][3] = pss[2][1] = pss[3][2] = {INF, -INF, -INF};
    pss[1][2] = pss[5][1] = pss[3][3] = {INF, -INF, INF};
    pss[2][2] = pss[4][3] = pss[3][1] = {INF, INF, -INF};
    pss[5][0] = pss[4][0] = pss[3][0] = {INF, INF, INF};
    return pss;
}

```

## 例题合集

# 圆合集

## Machining Disc Rotors 圆上线段处理，不必要的复杂度优化

https://codeforces.com/gym/101955/

### 题意：

一个圆O和n个圆交，交的部分去掉，且保证交的部分不重叠，问剩下的图形的直径(两点之间最大距离)。

### 分析：

首先答案的两点必然在圆O上。

证明：否则若有一点X在某段凹弧(即交的另一个圆的弧)上，记该线段的另一点为A，交的两个端点为C，D，必有AX<AC,AX<AD .因为$\triangle AXC$ 的$\angle X$为钝角，大边对大角。

然后考虑圆上的一条弦，若其圆心角为$\theta$ ，则弦长为
$$
2Rsin(\theta/2)
$$
在$[0,\pi]$上单调递增，所以对于圆上一点，弦的另一点让圆心角越大越好。

于是对于圆上每个点，找可以达到的圆心交最大的角。

具体实现就是对于每个交点作其对称点，若在原圆弧上则答案为半径，否则找到离其对称点最近的那个点连线。



### 实现：

$nlogn$:用圆心角作为参数维护圆上交出的线段，将弧线段拉直并翻倍，然后对x lowerbound(x+pi)，根据点是左端点还是右端点判断是否在圆弧上。注意最多只有一个线段会越过0度，将其右端点加pi处理即可。

但考虑到圆圆交的时候已经$n^2$了，所以可以全部用$n^2$,具体来说：

判对称点在弧上可以直接for所有的圆，判点在圆内（用2维解1维orz）

计算点点距离时就枚举所有点对。

```cpp
typedef double ld;
const double eps = 1e-7;
const double pi = acos(-1.);
int dcmp(double d) {
	return abs(d) < eps ? 0 : (d > 0 ? 1 : -1);
}
typedef complex<double> point;
#define X real()
#define Y imag()
struct V {
	ld x, y;
	V(ld x = 0, ld y = 0) :x(x), y(y) {};
	V operator +(V o) { return V(x + o.x, y + o.y); }
	V operator -(V o) { return V(x - o.x, y - o.y); }
	ld operator *(V o) { return x * o.x + y * o.y; }
	ld operator |(V o) { return x * o.y - y * o.x; }
	ld L() { return sqrt(x*x + y * y); }
	ld arg() { return  dcmp(y) >= 0 ? acos(x / sqrt(x*x + y * y)) : 2 * pi - acos(x / sqrt(x*x + y * y)); }//0~2pi
	ld cos() { return  x / sqrt(x*x + y * y); }
};

struct circle {
	point c;
	ld r;
	circle(point c = point(0, 0), ld r = 0) :c(c), r(r) {};
	point pt(ld a) {
		return point(c.X + cos(a)*r, c.Y + sin(a)*r);
	}
};
int CCintersect(circle c1, circle c2, ld &a1, ld &a2) {
	ld d = abs(c1.c - c2.c);
	if (dcmp(d) == 0) {
		if (dcmp(c1.r - c2.r) == 0)return -1;
		return 0;
	}
	if (dcmp(c1.r + c2.r - d) < 0)return 0;
	if (dcmp(abs(c1.r - c2.r) - d) > 0)return 0;
	ld a = arg(c2.c - c1.c);
	ld da = acos((c1.r*c1.r + d * d - c2.r*c2.r) / (2 * c1.r*d));
	a1=(a - da), a2 = (a + da);
	a1 = dcmp(a1) < 0 ? pi * 2 + a1 : a1;
	a2 = dcmp(a2) < 0 ? pi * 2 + a2 : a2;
	if (dcmp(a1-a2) == 0 )return 1;
	return 2;
}

struct seg {
	ld l, r;
	seg(ld l = 0, ld r = 0) :l(l), r(r) {};
};
bool cmp(seg a, seg b) {
	return a.l == b.l ? a.r < b.r : a.l < b.l;
}
typedef pair<ld, int> pdi;
ld deg(ld a) {
	return a / pi * 180;
}
int main()
{
	int t;
	cin >> t;

	rep(kase, 1, t) {
		int n; ld R;
		cin >> n >> R;
		point O(0, 0);
		circle c0(O, R);
		vector<pdi> S(n), s0;
		rep(i, 1, n) {
			ld a1, a2;
			ld x, y, r;
			cin >> x >> y >> r;
			circle c = circle(point(x, y), r);
			int cnt = CCintersect(c0, c, a1, a2);
			if (cnt == 2) {
				//no intersects
				s0.push_back({ a1,0 });
				s0.push_back({ a2,1 });
				if (dcmp(a1 - a2) == 1)a1 += 2 * pi;
			}
		}

		sort(s0.begin(), s0.end());
		int ns = s0.size();
		for (int i = 0; i < ns; i++)s0.push_back({ s0[i].first + 2 * pi,s0[i].second });
		ld ans = 0;
		rep(i, 0, ns-1) {
			ld a = s0[i].first + pi;
			pdi aa(a, 1);
			int p = lower_bound(s0.begin(), s0.end(), aa) - s0.begin();
			if (dcmp(s0[p].first - a) == 0) {
				ans = pi; break;
			}
			if (s0[p].second == 0) {
				ans = pi; break;
			}
			ld tmp = 0;
			s0[i].first;
			tmp = max( min(s0[p-1].first- s0[i].first,2*pi-( s0[p - 1].first- s0[i].first)), min(2*pi-(s0[p].first - s0[i].first), (s0[p].first - s0[i].first)));
			ans = max(ans, tmp);
		}

		cout << "Case #" << kase << ": " << Decimal << 2*sin(ans/2)*R << endl;
	}
	cin >> t;
	return 0;
}
```

## F.Distinct Distances 分类讨论，三点定圆 



https://codeforces.com/gym/101615/attachments

### 题意：

给你40个点，问到某终点不同的距离最少有几种，即问最少用几个同心圆可以覆盖(点在圆弧上)所有点。

### 分析:

（不严格的证明）

考虑最优解同心圆圆心O的位置。

若点共线，最优的O一定要同时经过两个点。所以O必在某两个点连线线段的中垂线上，由于所有点都共线时中垂线上的点等价，所以取线段中点即可。

若不共线，三个点时由于三点定圆，O的一个圆经过三个点是最优的。所以O可能某三点的圆上。

四个点时，两个圆经过四个点有两种情况：一个圆上三个点，另一个上一个点；每个圆上两个点，所以O可能为经过某四点的两个同心圆的圆心。

于是枚举所有情况，四点求圆心就是枚举所有连线线段，两两求中垂线交点。

### 实现：

用到了线线交，学习了jls的板子。



```cpp
P getLL(P k1, P k2,P k3, P k4) {
	db w1 = (k1 - k3)|( k4 - k3), w2 = (k4 - k3)| (k2 - k3); return (k1*w2 + k2 * w1) / (w1 + w2);
}
P getO(P a, P b, P c,P d) {
	P ab = b - a, cd = d - c;
	P nab = ab.rot90(), ncd = cd.rot90();
	P mab = (a + b) / 2; P mcd = (c + d) / 2;
	nab = mab + nab, ncd = mcd + ncd;
	P O=getLL(nab, mab, ncd, mcd);
	return O;
}
int n;
int getN(P O) {
	vector<double> tmp;
	rep(ii, 1, n) {
		tmp.push_back(O.distTo(p[ii]));
	}
	sort(tmp.begin(), tmp.end());
	int cnt = 1;
	rep(ii, 1, n - 1) {
		if (cmp(tmp[ii], tmp[ii - 1]) != 0)cnt++;
	}
	return cnt;
}
int main()
{
 cin >> n;
	rep(i, 1, n) {
		cin >> p[i].x>>p[i].y;
	}
	int ans = n;
	rep(i, 1, n)rep(j, i+1, n) {
		int cnt = getN((p[i] + p[j]) / 2); 
		ans = min(ans, cnt);
	}
	rep(i, 1, n)rep(j, i+1, n)rep(k, 1, n)rep(l,k+1,n){
		if (sign((p[i] - p[j]) | (p[k] - p[l])) == 0) {
			continue;
		}
		P O=getO(p[i], p[j], p[k],p[l]);
		int cnt = getN(O);
		ans = min(ans, cnt);
	}
	cout << ans << endl;
	cin >> n;
	return 0;
}
```



# 半平面交合集

朱泽园的论文。



## 例题

eg0[hdu多校1 code](http://acm.hdu.edu.cn/showproblem.php?pid=6590) （神似半平面交）

题意：定义关于三维向量$\boldsymbol{x}$的函数：其中$w_0=b,x_0=1$
$$
f(\boldsymbol{x})={\rm sign}(\sum_{i=0}^dw_i\cdot x_i)={\rm sign}(\boldsymbol{w^T\cdot x})
$$
给你$D = \{(\boldsymbol{x_1},y_1), (\boldsymbol{x_2},y_2), ...,(\boldsymbol{x_N},y_N)\}$问是否存在$\boldsymbol{w^T}$使得$f(\boldsymbol{x_i}) = y_i,i = 1,2,...,N$

其中
$$
{\rm sign}(x) = \begin{cases}    -1 & x < 0 \\    0 \ & x = 0 \\    1 \ & x > 0 \end{cases}\\(-10^5\leq x_{i,1},x_{i,2}\leq 10^5,y_i\in\{-1,1\})
$$
即给你n个不等式的x,y
$$
ax+by+c< \mathrm{or} >0
$$
问(a,b,c)是否有解。

eg1[P4196 [CQOI2006]凸多边形](https://www.luogu.org/problem/P4196)

逆时针给出n个凸多边形的顶点坐标，求它们交的面积。

eg2[半平面交 Equations](http://poj.org/problem?id=3689)  http://wikipedia.moesalih.com/Half_plane
$$
max\ \sum C_ix_i\\
st \  \sum A_ix_i=S\\
 \  \sum B_ix_i=T\\
 \ x_i\ge0
$$
对偶线性规划：n维参数向量满足两个等式，求另一个参数向量的极大值？



## 分析

### eg0

官方题解：

$d=2$时，$f(\boldsymbol{x})={\rm sign}(\boldsymbol{w^T\cdot x})=w_0+w_1x_1+w_2x_2$，$f(\boldsymbol{x})=0$对应于二维平面上的一条直线，直线一侧的点取值为 $1$，直线另一侧的取值为 $-1$。故该问题等价于能否找到一条直线将平面上的两类点分开，等价于判断这两类点分别组成的两个凸包是否相交。

理解:

我4个月来一直理解为n个不等式是否有公共解集，即半平面交。一直无法理解orz

但这样理解的话，题面应该给你n个不等式的a,b,c,问x,y是否有解或范围。（参数当成未知数，完全不是一道题233）

实际上的题意是，是否存在一条直线ax+by+c=0使得给定的n给点在上方（ax+by+c>0）或下方（ax+by+c<0）。

于是变成了判凸包是否有交点了。

注意这个问题不是求凸包并，所以只要暴力的判每个点是否在另一个凸包里，加上每条边是否相交即可。

### eg1

n个凸包并，可以把凸多边形的边看成直线，对所有直线进行半平面交即可。用了jls的模板，朱泽园的增量法

## 代码  

### eg0

学习了凸包+点在凸包内+线段交的写法。以及operator[]的用法。

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 105;

int n;

int sgn(long long x) {
    return (x > 0) - (x < 0);
}

struct P {
    long long d[3];
    long long& operator[](int x) {
        return d[x];
    }
    P () {}
    P (long long a, long long b, long long c) {
        d[0] = a; d[1] = b; d[2] = c;
    }
};

struct node {
    P x;
    int y;
} p[N];

P operator+(P a, P b) {
    P c;
    for (int i = 0; i < 3; i++)
        c[i] = a[i] + b[i];
    return c;
}

P operator-(P a, P b) {
    P c;
    for (int i = 0; i < 3; i++)
        c[i] = a[i] - b[i];
    return c;
}

P operator*(int a, P b) {
    P c;
    for (int i = 0; i < 3; i++)
        c[i] = a * b[i];
    return c;
}

bool operator<(P a, P b) {
    return a[1] < b[1] || (a[1] == b[1] && a[2] < b[2]);
}

long long operator*(P a, P b) {
    return a[1] * b[2] - a[2] * b[1];
}

long long operator^(P a, P b) {
    return a[1] * b[1] + a[2] * b[2];
}

long long det(P a, P b, P c) {
    return (b - a) * (c - a);
}

struct L {
    P a, b;
    L () {}
    L (P x, P y) {
        a = x; b = y;
    }
};

bool onSeg(P p, L s) {
    return sgn(det(p, s.a, s.b)) == 0 && sgn((s.a - p) ^ (s.b - p)) <= 0;
}

vector<P> convex(vector<P> p) {
    vector<P> ans, S;
    for (int i = 0; i < p.size(); i++) {
        while (S.size() >= 2
                && sgn(det(S[S.size() - 2], S.back(), p[i])) <= 0)
                    S.pop_back();
        S.push_back(p[i]);
    }
    ans = S;
    S.clear();
    for (int i = (int)p.size() - 1; i >= 0; i--) {
        while (S.size() >= 2
                && sgn(det(S[S.size() - 2], S.back(), p[i])) <= 0)
                    S.pop_back();
        S.push_back(p[i]);
    }
    for (int i = 1; i + 1 < S.size(); i++)
        ans.push_back(S[i]);
    return ans;
}

bool PointInPolygon(P p, vector<P> poly) {
    int cnt = 0;
    for (int i = 0; i < poly.size(); i++) {
        if (onSeg(p, L(poly[i], poly[(i + 1) % poly.size()]))) return true;
        int k = sgn(det(poly[i], poly[(i + 1) % poly.size()], p));
        int d1 = sgn(poly[i][2] - p[2]);
        int d2 = sgn(poly[(i + 1) % poly.size()][2] - p[2]);
        if (k > 0 && d1 <= 0 && d2 > 0) cnt++;
        if (k < 0 && d2 <= 0 && d1 > 0) cnt--;
    }
    if (cnt != 0) return true;
    return false;
}

bool SegmentIntersection(L l1, L l2) {
    long long c1 = det(l1.a, l1.b, l2.a), c2 = det(l1.a, l1.b, l2.b);
    long long c3 = det(l2.a, l2.b, l1.a), c4 = det(l2.a, l2.b, l1.b);
    if (sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0) return true;
    if (sgn(c1) == 0 && onSeg(l2.a, l1)) return true;
    if (sgn(c2) == 0 && onSeg(l2.b, l1)) return true;
    if (sgn(c3) == 0 && onSeg(l1.a, l2)) return true;
    if (sgn(c4) == 0 && onSeg(l1.b, l2)) return true;
    return false;
}

bool ConvexHullDivide(vector<P> p1, vector<P> p2) {
    for (int i = 0; i < p1.size(); i++)
        if (PointInPolygon(p1[i], p2))
            return false;
    for (int i = 0; i < p2.size(); i++)
        if (PointInPolygon(p2[i], p1))
            return false;
    for (int i = 0; i < p1.size(); i++)
        for (int j = 0; j < p2.size(); j++)
            if (SegmentIntersection(L(p1[i], p1[(i + 1) % p1.size()]), L(p2[j], p2[(j + 1) % p2.size()])))
                return false;
    return true;
}

bool check() {
    vector<P> p1, p2;
    for (int i = 1; i <= n; i++) {
        if (p[i].y == 1)
            p1.push_back(p[i].x);
        else
            p2.push_back(p[i].x);
    }
    vector<P> c1, c2;
    c1 = convex(p1);
    c2 = convex(p2);
    if (ConvexHullDivide(c1, c2)) return true;
    return false;
}

int f(P w, P x) {
    long long sum = 0;
    for (int i = 0; i < 3; i++)
        sum += w[i] * x[i];
    return sgn(sum);
}

void PLA() {
    P w = P(0, 0, 0);
    int i = 1, cnt = 0;
    long long cc = 0;
    while (true) {
        cc++;
        if (f(w, p[i].x) != p[i].y) {
            w = w + p[i].y * p[i].x;
            cnt = 0;
        }
        else {
            if (++cnt == n) break;
        }
        i = i + 1;
        if (i > n) i -= n;
    }
    cout << cc << endl;
}

int main() {
    int testcase;
    cin >> testcase;
    while (testcase--) {
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> p[i].x[1] >> p[i].x[2] >> p[i].y;
            p[i].x[0] = 1;
        }
        if (!check())
            puts("Infinite loop!");
        else {
            puts("Successful!");
        }
    }
    return 0;
}

```

### eg1

加了个极角排序，结果那个是以原点为极角的，把顺序打乱了，de了好久orz。极角排序要注意极点啊。

然后仔细看了看jls的凸包，竟然没有极角排序？？貌似是正着来一遍，反着来一边，还要理解一下啊

```cpp
const int maxn = 105;
typedef double db;
typedef double ld;
const double eps = 1e-7;
const double pi = acos(-1.);
inline int sign(double d) { return d<-eps ? -1 : d>eps; }
inline int cmp(db a, db b) { return sign(a - b); }
struct P {
	db x, y;
	P() {};
	P(db x, db y) :x(x), y(y) {}
	void read() { cin >> x >> y; }
	void write() { cout << '(' << x << ',' << y << ')'; }
	P operator + (P o) { return P(x + o.x, y + o.y); }
	P operator - (P o) { return P(x - o.x, y - o.y); }
	P operator *(db d) { return P(x * d, y * d); }
	P operator /(db d) { return P(x / d, y / d); }
	db operator *(P o) { return (x*o.x + y * o.y); }
	db operator |(const P &o) const{ return x * o.y - y * o.x; }
	bool operator==(P p)const {
		return cmp(x, p.x) == 0 && cmp(y, p.y) == 0;
	}
	db abs() { return (x*x + y * y); }
	db abs2() { return (x*x + y * y); }
	db distTo(P p) { return (*this - p).abs(); }
	db alpha() { return atan2(y, x); }
	P rot90() { return P(-y, x); }
	P rot(db a) { return P(x*cos(a) - y * sin(a), x*sin(a) + y * cos(a)); }
	P unit() { return *this / abs(); }
	int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }
}p[maxn], q[maxn];
P getLL(P k1, P k2,P k3, P k4) {
	db w1 = (k1 - k3)|( k4 - k3), w2 = (k4 - k3)| (k2 - k3); return (k1*w2 + k2 * w1) / (w1 + w2);
}
int compareangle(  P k1, P k2) {
	return k1.quad()<k2.quad() || (k1.quad() == k2.quad() && sign(k1| k2)>0);
}
struct L {
	//p[0]->p[1]
	P p[2];
	L(P k1, P k2) { p[0] = k1; p[1] = k2; }
	P& operator [](int k){ return p[k]; }
	P dir() { return p[1] - p[0]; }
	int include(P k) { return sign((p[1] - p[0])|( k - p[0]))>0; }//判点在线上
};
P getLL(L k1, L k2) {return getLL(k1[0], k1[1], k2[0], k2[1]);}
int parallel(L k1, L k2) { return sign((k1.dir()| k2.dir())) == 0; }
int sameDir(L k1, L k2) { return parallel(k1, k2) && sign(k1.dir()* k2.dir()) == 1; }
int checkpos(L k1, L k2, L k3) { return k3.include(getLL(k1, k2)); }//k1k2交点是否在k3上
int operator < (L k1, L k2) {
	if (sameDir(k1, k2)) return k2.include(k1[0]);
	return compareangle(k1.dir(), k2.dir());
}
vector<L> getHL(vector<L> &V) { // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针
	sort(V.begin(), V.end()); 
	deque<L> q;
	for (int i = 0; i<(int)V.size(); i++) {
		if (i&&sameDir(V[i], V[i - 1])) continue;
		while (q.size()>1 && !checkpos(q[q.size() - 2], q[q.size() - 1], V[i])) q.pop_back();//V[i]把凸包（半平面）切得更小
		while (q.size()>1 && !checkpos(q[1], q[0], V[i])) q.pop_front();
		q.push_back(V[i]);
	}
	while (q.size()>2 && !checkpos(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back();
	while (q.size()>2 && !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front();
	vector<L>ans; for (int i = 0; i<q.size(); i++) ans.push_back(q[i]);
	return ans;
}
db area(vector<P> A) { // 多边形用 vector<point> 表示 , 逆时针 
	db ans = 0;
	for (int i = 0; i < A.size(); i++) {
		ans += (A[i] | A[(i + 1) % A.size()]);
	}
	return ans / 2;
}
vector<L> lin;
vector<P> pin;
int main()
{

	int n;
	cin >> n;
	rep(i, 1, n) {
		vector<P> tmp;
		int m; cin >> m;
		rep(i, 1, m) {
			P p;
			p.read();
			tmp.push_back(p);
		}
		for (int i = 0; i < tmp.size(); i++) {
			lin.push_back(L(tmp[i], tmp[(i + 1) % tmp.size()]));
		}
	}
	lin = getHL(lin);
	for (int i = 0; i < lin.size(); i++) {
		pin.push_back(getLL(lin[i], lin[(i + 1) % lin.size()]));
	}
	printf("%.3lf", area(pin));
	cin >> n;
	return 0;
}
//--------造数据代码------
vector<P> ConvexHull(vector<P>A, int flag = 1) { // flag=0 不严格 flag=1 严格 
	int n = A.size(); vector<P>ans(n * 2);
	sort(A.begin(), A.end()); int now = -1;
	for (int i = 0; i<A.size(); i++) {
		while (now>0 && sign((ans[now] - ans[now - 1])| (A[i] - ans[now - 1]))<flag) now--;
		ans[++now] = A[i];
	} int pre = now;
	for (int i = n - 2; i >= 0; i--) {
		while (now>pre&&sign((ans[now] - ans[now - 1])|( A[i] - ans[now - 1]))<flag) now--;
		ans[++now] = A[i];
	} ans.resize(now); return ans;
}
vector<P> ch;
#include<ctime>
#include<random>

int main()
{
	mt19937_64 rd(time(0));
	int n; cin >> n;
	
	rep(i, 1, n) {
		ch.push_back(P(rd() % 10, rd() % 10));
	}	

	ch = ConvexHull(ch, 1);
	cout << ch.size() << endl;
	for (auto p : ch) {
		cout << p.x << ' ' << p.y << endl;
	}
	cin >> n;
	return 0;
}
```



# 极角排序合集 atan2与const&优化 复杂度选择

## 题意与分析

板题：给2e3个点，求有几个直角三角形

eg1 [A - Angle Beats](https://codeforces.com/gym/255930/problem/A) 增加询问：2e3个询问点，问每个询问点与给定点分别组成几个直角三角形。

eg2 [A sky full of stars](https://codeforces.com/gym/101992/problem/I) 增加限制：直角三角形面积$\in [L,R]$

### 板题解法：

对于任意点A，要计算以 A 为直角顶点的三角形个数，只需要对 n 个点关于 A 做一个极角排序，然后统计有多少个点对 (B, C)，使得 AB 垂直 AC，这个用尺取是很好求,但是不大好写$O(n(nlogn+n))$。

可以用二分简化，直接在极角排序的数组中lowerbound垂直于AB的边即可。n2nlogn

也可以用map简化，把所有边存在map里，然后map[v.rot90()]来直接查询$n(2nlogn)$。

这里复杂度是由排序造成的nlogn,所以再用尺取优化为n没有意义。

### 例一分析：

按询问点A是否是直角顶点分类讨论，若是则用板题的方法。

如果询问点A不是直角顶点，考虑离线做法。先把所有的询问点读进来，然后枚举 n 个给定点，对于每个给定点 B，给其他n + q − 1 个点关于 B 进行极角排序并按极角序扫描所有点，每扫到一个询问点就统计垂直方向上的给定点的个数并把答案累加到当前询问。$O(q(nlogn+n)+n((n+q)log(n+q)+n+q))=O(nqlogn+n(n+q)log(n+q))$

如果用map复杂度为$O((n+q)^2\log n)$快1/6

### 对于例二，

我们极角排序时角度一样的按照长度排序，设直角点和两个指针组成 $RT \ang  p_1op_2$ ，然后从前往后枚举op1射线上的点，计算op2上有几个符合条件的，$O(n(nlogn+n))$

[交题记录](https://codeforces.com/gym/255930/)



## eg2 代码

新姿势：用atan2极角排序；`for (int j = 1, k = 1; j <= m; j++) `来尺取；环上处理：复制两边即可。

```cpp
typedef long long ll;

const int maxn = 2e3 + 5;
typedef double db;
const double eps = 1e-11;
const double pi = acos(-1.);
inline int sign(double d) { return d<-eps ? -1 : d>eps; }
inline int cmp(db a, db b) { return sign(a - b); }
typedef pair<ll, ll> point;
typedef long double ld;
#define x first
#define y second
inline ll area(point a,point b,point c) {
	return abs(a.x*b.y + b.x*c.y + c.x*a.y - a.y*b.x - b.y*c.x - c.y*a.x);
}
inline ll dot(point a, point b) {
	return a.x*b.y - a.y*b.x;
}
point pin[maxn];
pair<ld,point> p[maxn];
int main() {
	freopen("points.in", "r", stdin);
	FAST_IO;
	int t;
	cin >> t;
	while (t--) {
		ll n, l, r;
		cin >> n >> l >> r;
		l += l; r += r;
		rep(i, 1, n)cin >> pin[i].x>>pin[i].y;
		int ans = 0;
		rep(i, 1, n) {
			int m = 0;
			rep(j, 1, n) if(i!=j){
				p[++m] = make_pair(atan2(pin[j].y-pin[i].y,pin[j].x-pin[i].x),point( pin[j].x - pin[i].x,pin[j].y - pin[i].y));
			}
			sort(p + 1, p + m+1);
			rep(j, 1, m) {
				p[j + m] = p[j];
				p[j + m].x += pi *2 ;
			}
			for (int j = 1, k = 1; j <= m; j++) {
				while (k < j + m and cmp(p[k].x, p[j].x + pi / 2) == -1) ++k;
				int at = k;
				while (at < j + m and cmp(p[at].x, p[j].x + pi / 2) == 0) {
					ll now = dot(p[j].y, p[at].y);
					if (l <= now and now <= r)++ans; ++at;
				}
			}
		}
		cout << ans << endl;
	}
	cin >> t;
	return 0;
}

```



## eg 1 代码

两遍尺取。

```cpp
P v[maxn];
int ans[maxn];
bool cmpr(const P &a, const P &b) {
 
	if (a.quad() != b.quad())return a.quad() < b.quad();
	else return sign(a | b) == 1;
}
 
int out[maxn];
int main() {
	FAST_IO;
 
	ll np, nq;
	cin >> np >> nq;
 
	rep(i, 1, np)cin >> pin[i].x >> pin[i].y, pin[i].id = i;
	rep(i, 1, nq)cin >> qin[i].x >> qin[i].y, qin[i].id = i + np;
 
	rep(i, 1, nq) {
		int m = 0;
		rep(j, 1, np) {
			p[++m] = pin[j] - qin[i];
		}
		sort(p + 1, p + m + 1, cmpr);
		rep(j, 1, m) {
			p[j + m] = p[j];
		}
		for (int j = 1, k = 1; j <= m; j++) {
			while (k < j + m and (p[j] * p[k])>0 and (p[j] | p[k]) >= 0) ++k;
			int at = k;
			while (at < j + m and (p[at] * p[j]) == 0 and (p[j] | p[at]) >= 0) {
				++out[i]; ++at;
			}
		}
	}
 
	rep(i, 1, np) {
		int m = 0;
		rep(j, 1, np) if (i != j) {
			p[++m] = pin[j] - pin[i], p[m].id = pin[j].id;;
		}
		rep(j, 1, nq) {
			p[++m] = qin[j] - pin[i], p[m].id = qin[j].id;
		}
		sort(p + 1, p + m + 1, cmpr);
		rep(j, 1, m) {
			p[j + m] = p[j];
		}
		for (int j = 1, k = 1; j <= m; j++) {
			while (k < j + m and (p[j] | p[k]) >= 0 and (p[j] * p[k])>0) ++k;
			int at = k;
 
			while (at < j + m and (p[j] | p[at]) >= 0 and (p[at] * p[j]) == 0) {
				if ((p[at].id>np) ^ p[j].id>np)++out[p[j].id>np ? p[j].id - np : p[at].id - np]; ++at;
			}
		}
	}
	rep(i, 1, nq)
		cout << out[i] << endl;
	cin >> nq;
	return 0;
}
```

